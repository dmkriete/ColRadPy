#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Dec 11 10:45:42 2020

@author: Matt Kriete

Fractional abundance describes the charge state distribution of an ion species
for particular plasma conditions. This example calculates the fractional
abundance obtained in steady state using collisional-radiative coefficients in
ADF11 files. At minimum, these are the effective ionization (SCD) and
recombination (ACD) rates. For metastable-resolved calculations the cross-
coupling (QCD) and parent cross-coupling (XCD) rates are also needed. Including
the effects of charge-exchange recombination with neutral hydrogen additionally
requires the CCD rates. This example script requires the rates for the species
of interest to be downloaded from ADAS or open-ADAS and stored in a specified
directory on the local machine.

The fractional abundance depends on the electron temperature and density. The
temperature dependence is stronger, and below 1e14 cm^-3 the density dependence
is usually negligible. The plots generated by this example are clearest when
running the calculation for a large number of electron temperatures and small
number of electron densities.

Transport of ions through a plasma with spatially varying temperature/density
can cause the local fractional abundance to deviate substantially from the
expected steady-state distribution. To model the effect of transport, this
calculation allows the user to specify a 'dwell time' characterizing the
strength of transport along with a source of ions for each charge/metastable
state. A smaller dwell time corresponds to stronger transport. To model a
situation where ions are moving from regions of lower to higher temperature
(e.g. influx of sputtered neutral impurities), the source distribution should
be weighted toward lower charge states. To model the opposite (e.g. outflux of
fully ionized impurities from the confined plasma into the scrape-off layer),
the source distribution should be weighted toward higher charge states.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.lines as mlines
import colradpy


#%% Specify element to analyze and path to ADF11 files
element_name = 'carbon'
element_symbol = 'C'
num_charge_states = 7  # Atomic number + 1
year = '96'
metastable_resolved = False
# atomic_data_path = ''  # Specify directory where ADF11 files are stored locally


#%% Build list of atomic data file paths
if metastable_resolved:
    r = 'r'
else:
    r = ''
files = [
    os.path.join(atomic_data_path, f'scd{year}{r}_{element_symbol.lower()}.dat'),
    os.path.join(atomic_data_path, f'acd{year}{r}_{element_symbol.lower()}.dat'),
    # os.path.join(atomic_data_path, f'ccd{year}{r}_{element_symbol.lower()}.dat'),
]
if metastable_resolved:
    files.extend([
        os.path.join(atomic_data_path, f'qcd{year}{r}_{element_symbol.lower()}.dat'),
        os.path.join(atomic_data_path, f'xcd{year}{r}_{element_symbol.lower()}.dat'),
    ])


#%% Run time-independent (steady state) ionization balance
# Set up ionization balance
ion = colradpy.ionization_balance(
    files, # a text array of the files used for the ionization balance
    temp_grid=np.geomspace(2.5e-1, 1e4, num=500), # Electron temperature in eV
    dens_grid=np.array([1e13]), # Electron density in cm^-3
    htemp_grid=np.array([5]),  # Neutral hydrogen temperature in eV
    hdens_grid=np.array([5e11]),  # Neutral hydrogen density in cm^-3
    use_cx=False,
    input_files_type="adf11",
)

# Specify the transport and relative source for each charge state
ne_tau = np.inf  # cm^-3 s, no transport
# ne_tau = 1e11  # cm^-3 s, moderate transport
# ne_tau = 1e9  # cm^-3 s, strong transport
num_metas = sum(ion.data["input_file"]["scd"]["metas"])
source = np.zeros((num_metas, len(ion.data["user"]["temp_grid"]), len(ion.data["user"]["dens_grid"])))
source[0] = 1  # Pure neutral source: models transport from lower Te region
# source[-1] = 1  # Pure fully ionized source: models transport from higher Te region

# Take the rates interpolated from the adf11 file and put then in the ionization balance matrix
ion.populate_ion_matrix(ne_tau, source)

# Solve the ionization balance matrix
ion.solve_time_independent()


#%% Plot steady-state fractional abundances
def plot_fractional_abundance(ne_index, TH_index=None, nH_index=None):
    title = (
        f"Steady-state fractional abundance for {element_name}" + "\n"
        fr"$n_\mathrm{{e}}$ = {ion.data['user']['dens_grid'][ne_index]:5.1e} $\mathrm{{cm}}^{{-3}}$  "
        fr"$\tau$ = {ne_tau / ion.data['user']['dens_grid'][ne_index]:5.1e} s  "
    )
    if np.any(ion.data["user"]["use_cx"]):
        title += (
            "\n"
            fr"$T_\mathrm{{H}}$ = {ion.data['user']['htemp_grid'][TH_index]:.1f} eV  "
            fr"$n_\mathrm{{H}}$ = {ion.data['user']['hdens_grid'][nH_index]:5.1e} $\mathrm{{cm}}^{{-3}}$  "
        )

    fig, ax = plt.subplots(constrained_layout=True)

    metas = ion.data["input_file"]["scd"]["metas"]  # number of metastables for each charge state
    m = 0  # index of the metastable state corresponding to the ground state of the current charge state
    colors = plt.get_cmap("rainbow")(np.linspace(0, 1, num_metas))
    linestyles = ["--", ":", "-.", (5, (10, 3))]  # TODO: Will need to expand this for atoms with more than 4 metastables per charge state
    linestyles = linestyles[:np.max(metas)]  # Reduce number of linestyles down to just what is needed

    for charge_state in range(num_charge_states):  # loop over all charge states
        for meta in range(metas[charge_state]):
            ax.plot(
                ion.data['user']['temp_grid'],
                ion.data['processed']['pops_ss'][m + meta, :, ne_index],
                color=colors[charge_state],
                linestyle=linestyles[meta],
            )
        if charge_state == 0:
            element_label = f'$\mathrm{{{element_symbol}}}^{{{charge_state}}}$'
        else:
            element_label = f'$\mathrm{{{element_symbol}}}^{{{charge_state}\plus}}$'
        ax.plot(
            ion.data['user']['temp_grid'],
            np.sum(ion.data['processed']['pops_ss'][m:m + metas[charge_state], :, ne_index], axis=0),
            color=colors[charge_state],
            linestyle="-",
            label=element_label,
        )
        m += metas[charge_state]  # Increment to get metastable index for ground of next charge state

    leg1 = ax.legend(title="charge state", loc="lower right", bbox_to_anchor=(0.5, 0.44, 0.49, 0.55))
    ax.add_artist(leg1)
    leg1.set_draggable(True)
    if metastable_resolved:
        handles = []
        for i, linestyle in enumerate(linestyles):
            if i == 0:
                label = "ground"
            else:
                label = str(i)
            handles.append(mlines.Line2D([], [], linestyle=linestyle, color="black", label=label))
        handles.append(mlines.Line2D([], [], linestyle="-", color="black", label="total"))
        leg2 = ax.legend(handles=handles, title="metastable", loc="upper right", bbox_to_anchor=(0.5, 0, 0.49, 0.44))
        leg2.set_draggable(True)

    ax.set_xlim([ion.data['user']['temp_grid'].min(), ion.data['user']['temp_grid'].max()])
    ax.set_xscale('log')
    ax.set_ylim([0, 1])
    ax.set_xlabel("Electron temperature (eV)")
    ax.set_ylabel("Fractional abundance")
    ax.set_title(title)

for ne_index in range(len(ion.data["user"]["dens_grid"])):
    plot_fractional_abundance(ne_index)
